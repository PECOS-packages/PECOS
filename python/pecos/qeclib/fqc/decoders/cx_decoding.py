from pecos.slr import CReg, util


class RotateCXSyndromes:
    def __init__(
        self,
        last_syn1: CReg,
        last_syn2: CReg,
        syn_tq: CReg,
    ):
        """Does the flagged 10 qubit code QEC.

        Attributes:
            last_syn1: syndromes associated with q1.
            last_syn2: syndromes associates with q2
            syn_tq: The syndromes generated by the CX gates.

        """
        self.last_syn1 = last_syn1
        self.last_syn2 = last_syn2
        self.syn_tq = syn_tq

    def qasm(self):
        qasm = f"""
        // ======= Begin rotate CX syndromes =======

        // Determine the standard syndromes for q1 and q2.
        {self.last_syn1[0]} = {self.syn_tq[1]};
        {self.last_syn1[1]} = {self.syn_tq[2]};
        {self.last_syn1[2]} = {self.syn_tq[3]};
        {self.last_syn1[3]} = {self.syn_tq[0]} ^ {self.syn_tq[1]} ^ {self.syn_tq[2]} ^ {self.syn_tq[3]};

        {self.last_syn2[0]} = {self.syn_tq[5]};
        {self.last_syn2[1]} = {self.syn_tq[6]};
        {self.last_syn2[2]} = {self.syn_tq[5]} ^ {self.syn_tq[6]} ^ {self.syn_tq[7]};
        {self.last_syn2[3]} = {self.syn_tq[4]} ^ {self.last_syn2[2]};

        // ======= End rotate CX syndromes  =======
        """
        return util.rm_white_space(qasm)


class CXWasmDecoding:
    def __init__(
        self,
        syn_tq: CReg,
        f: CReg,
        check_scratch1: CReg,
    ):
        """Does the flagged 10 qubit code QEC.

        Attributes:
            syn_tq: The syndromes generated by the CX gates.

        """
        self.syn_tq = syn_tq
        self.f = f
        self.check_scratch1 = check_scratch1

    def qasm(self):
        qasm = f"""
        // ======= Begin CX decoding =======

        // Given the syndromes from the CX gate... decode
        if({self.check_scratch1} > 0) double_decode({self.syn_tq});
        if({self.check_scratch1} > 0) double_decode_flag({self.f}, {self.syn_tq});

        // ======= End CX decoding =======
        """
        return util.rm_white_space(qasm)


class PullPF:
    def __init__(
        self,
        pf1: CReg,
        pf2: CReg,
        num_q1: CReg,
        num_q2: CReg,
    ):
        """Does the flagged 10 qubit code QEC.

        Arguments:
            pf1:

        """
        self.pf1 = pf1
        self.pf2 = pf2
        self.num_q1 = num_q1
        self.num_q2 = num_q2

    def qasm(self):
        qasm = f"""
        // ======= Begin pulling the Pauli frame =======

        // Get the Pauli frame for q1 and q2
        {self.pf1} = return_PFU({self.num_q1});
        {self.pf2} = return_PFU({self.num_q2});

        // ======= End pulling the Pauli frame =======
        """
        return util.rm_white_space(qasm)


class PFRotation:
    def __init__(
        self,
        pf1: CReg,
        pf2: CReg,
        flip: CReg,
        basis1: CReg,
        basis2: CReg,
    ):
        """Does the flagged 10 qubit code QEC.

        Arguments:
            pf1:

        """
        self.pf1 = pf1
        self.pf2 = pf2
        self.flip = flip
        self.basis1 = basis1
        self.basis2 = basis2

    def qasm(self):
        qasm = f"""
        // ---- PF rotation ---
        if({self.basis1[0]} == 1) {self.flip[0]} = {self.flip[0]} ^ {self.pf1[1]};  // state in basis X apply logical Z
        if({self.basis1[1]} == 1) {self.flip[0]} = {self.flip[0]} ^ {self.pf1[0]};  // state in basis Z apply logical X

        if({self.basis2[0]} == 1) {self.flip[1]} = {self.flip[1]} ^ {self.pf2[1]};  // state in basis X apply logical Z
        if({self.basis2[1]} == 1) {self.flip[1]} = {self.flip[1]} ^ {self.pf2[0]};  // state in basis Z apply logical X
        // ---- PF rotation ---

        """
        return util.rm_white_space(qasm)
